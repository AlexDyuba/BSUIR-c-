Начиная с C++11, конструкторам разрешено вызывать другие конструкторы. Этот процесс называется делегированием
конструкторов (или «цепочкой конструкторов»). Чтобы один конструктор вызывал другой,
нужно просто сделать вызов этого конструктора в списке инициализации членов. Например:

class Boo
{
private:

public:
    Boo()
    {
        // Часть кода X
    }

    Boo(int value): Boo() // используем конструктор по умолчанию Boo() для выполнения части кода X
    {
        // Часть кода Y
    }

};

Всё работает как нужно. Убедитесь, что вы вызываете конструктор из списка инициализации членов,
а не из тела конструктора.

Вот еще один пример использования делегирующих конструкторов для сокращения дублированного кода:

#include <iostream>
#include <string>

class Employee
{
private:
    int m_id;
    std::string m_name;

public:
    Employee(int id=0, const std::string &name=""):
        m_id(id), m_name(name)
    {
        std::cout << "Employee " << m_name << " created.\n";
    }

    // Используем делегирующие конструкторы для сокращения дублированного кода
    Employee(const std::string &name) : Employee(0, name) { }
};

int main()
{
    Employee a;
    Employee b("Ivan");

    return 0;
}
Этот класс имеет 2 конструктора (один из которых вызывает другой). Таким образом, количество дублированного кода
сокращено (нам нужно записать только одно определение конструктора вместо двух).

Несколько заметок о делегирующих конструкторах

Во-первых, конструктору, который вызывает другой конструктор, не разрешается выполнять какую-либо
инициализацию членов класса. Поэтому конструкторы могут либо вызывать другие конструкторы, либо выполнять инициализацию,
но не всё сразу.

Во-вторых, один конструктор может вызывать другой конструктор, в коде которого может находиться вызов первого
конструктора. Это создаст бесконечный цикл и приведет к тому, что память стека закончится и произойдет сбой.
Вы можете избежать этого, убедившись, что в конструкторе, который вызывается, нет вызова первого
(и вообще любого другого) конструктора. Будьте аккуратны и не используйте вложенные вызовы конструкторов.